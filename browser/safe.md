# 前端安全
![](https://segmentfault.com/img/remote/1460000041454110)
## XSS(跨站脚本攻击)
`Cross-Site Scripting`（跨站脚本攻击）简称 `XSS`，是一种代码注入攻击。攻击者通过在目标网站上注入恶意脚本，使之在用户的浏览器上运行。利用这些恶意脚本，攻击者可获取用户的敏感信息如 `Cookie`、`SessionID` 等，进而危害数据安全。

### XSS分类

#### 反射型XSS攻击
顾名思义，恶意 `JavaScript` 脚本属于用户发送给网站请求中的一部分，随后网站又将这部分返回给用户，恶意脚本在页面中被执行。一般发生在前后端一体的应用中，服务端逻辑会改变最终的网页代码。

反射型 XSS 的攻击步骤：
- 攻击者构造出特殊的 `url`，其中包含恶意代码;
- 用户打开带有恶意代码的 `url` 时，网站服务端将恶意代码从 `url` 中取出，拼接在 `HTML` 中返回给浏览器
- 用户浏览器接收到响应后解析执行，混在其中的恶意代码也被执行
- 恶意代码窃取用户数据并发送到攻击者的网站，或者冒充用户的行为，调用目标网站接口执行攻击者指定的操作

#### 基于DOM的XSS攻击
目前更流行前后端分离的项目，反射型 `XSS` 无用武之地。 但基于`DOM`的`XSS`攻击不需要经过服务器，我们知道，网页本身的 `JavaScript` 也是可以改变 `HTML` 的，黑客正是利用这一点来实现插入恶意脚本。

基于DOM 的 XSS 攻击步骤:
- 攻击者构造出特殊的 `url`，其中包含恶意代码
- 用户打开带有恶意代码的 `url`
- 用户浏览器接收到响应后解析执行，前端 `JavaScript` 取出 `url` 中的恶意代码并执行
- 恶意代码窃取用户数据并发送到攻击者的网站，或者冒充用户的行为，调用目标网站接口执行攻击者指定的操作

#### 存储型XSS攻击
又叫持久型 `XSS`，顾名思义，黑客将恶意 `JavaScript` 脚本长期保存在服务端数据库中，用户一旦访问相关页面数据，恶意脚本就会被执行。常见于**搜索**、**微博**、**社区贴吧评论**等

存储型 XSS 的攻击步骤：
- 攻击者将恶意代码提交到目标网站的数据库中
- 用户打开目标网站时，网站服务端将恶意代码从数据库取出，拼接在 `HTML` 中返回给浏览器
- 用户浏览器接收到响应后解析执行，混在其中的恶意代码也被执行
- 恶意代码窃取用户数据并发送到攻击者的网站，或者冒充用户的行为，调用目标网站接口执行攻击者指定的操作

### 几种`XSS`攻击类型的区别

- 基于`DOM的XSS` 攻击中，取出和执行恶意代码由**浏览器端**完成，**属于前端 `JavaScript` 自身的安全漏洞**，其他两种 `XSS` 都属于**服务端的安全漏洞**
- `反射型的 XSS` 的恶意脚本存在 `url` 里,攻击常见于通过 `url` 传递参数的功能，如**网站搜索**、**跳转**等
- `存储型 XSS` 的恶意代码存在**数据库**里,攻击常见于带有用户保存数据的网站功能，如**论坛发帖**、**商品评论**、**用户私信**等

### XSS防范措施

由上面对XSS攻击的介绍我们知道，XSS攻击主要有两大步骤：
- 攻击者提交恶意代码
- 浏览器执行恶意代码

所以我们可以针对这两点来制定防范措施：
#### 输入过滤
在用户提交时，由前端过滤输入，然后提交到后端，**这种方法不可行**，因为攻击者可能绕过前端过滤，直接构造请求，提交恶意代码。一般在写入数据库前，后端对输入数据进行过滤。虽然输入侧过滤能够在某些情况下解决特定的 `XSS` 问题，但会引入很大的不确定性和乱码问题。在防范 `XSS` 攻击时应**避免此类方法**。

#### 预防存储型和反射型 XSS 攻击

- 改成纯前端渲染，把代码和数据分隔开
- 对 输出的`HTML` 做**充分转义**

#### 预防 `DOM型XSS攻击`
`DOM型XSS攻击`，实际上就是网站前端 `JavaScript` 代码本身不够严谨，把不可信的数据当作代码执行了。

在使用 `.innerHTML`、`.outerHTML`、`document.write()` 时要特别小心，**不要把不可信的数据作为 `HTML` 插到页面上**，而应尽量使用 `.textContent`、`.setAttribute()` 等。

如果用 `Vue/React` 技术栈，并且不使用 `v-html`/`dangerouslySetInnerHTML` 功能，就在前端 `render` 阶段**避免** `innerHTML`、`outerHTML`的 `XSS` 隐患。

DOM 中的内联事件监听器，如 `location`、`onclick`、`onerror`、`onload`、`onmouseover` 等，`<a>` 标签的 `href` 属性，`JavaScript` 的 `eval()`、`setTimeout()`、`setInterval()` 等，都能把字符串作为代码运行。如果不可信的数据拼接到字符串中传递给这些 `API`，很容易产生安全隐患，请务必避免。

#### CSP(Content Security Policy，内容安全策略),定义域白名单
严格的 `CSP` 在 `XSS` 的防范中可以起到以下的作用：
- 禁止加载外域代码，防止复杂的攻击逻辑
- 禁止外域提交，网站被攻击后，用户的数据不会泄露到外域
- 禁止内联脚本执行（规则较严格，目前发现 `GitHub` 使用）
- 禁止未授权的脚本执行（新特性，`Google Map` 移动版在使用）
- 合理使用上报可以及时发现 `XSS`，利于尽快修复问题

#### 设置 `Cookie` 的 `HttpOnly` 属性，禁止`JavaScript`读取`cookie`
#### 验证码：防止脚本冒充用户提交危险操作

## CSRF(跨站请求伪造)
`CSRF（Cross-site request forgery）`：攻击者诱导受害者进入**第三方网站**，在第三方网站中，向被攻击网站发送跨站请求。利用受害者在被攻击网站已经获取的注册凭证，绕过后台的用户验证，达到冒充用户对被攻击的网站执行某项操作的目的。

### CSRF攻击步骤
典型的CSRF攻击是这样的：
- 受害者登录`A`网站，并且保留了登录凭证(`Cookie`)
- 攻击者引诱受害者访问`B`网站
- `B`网站向`A`网站发送了一个请求（这个就是下面将介绍的几种伪造请求的方式），浏览器请求头中会默认携带 `A` 网站的 `Cookie`
- `A` 网站服务器收到请求后，经过验证发现用户是登录了的，所以会处理请求

### 常见的CSRF攻击类型
#### GET类型的CSRF
GET类型的CSRF利用非常简单，只需要一个HTTP请求，一般会这样利用：
```html
<img src="http://bank.example/withdraw?amount=10000&for=hacker" > 
```
在受害者访问含有这个`img`的页面后，浏览器会自动向`http://bank.example/withdraw?account=xiaoming&amount=10000&for=hacker`发出一次`HTTP`请求。`bank.example`就会收到包含受害者登录信息的一次跨域请求

#### POST类型的CSRF
这种类型的`CSRF`利用起来通常使用的是一个自动提交的表单，如：
```html
 <form action="http://bank.example/withdraw" method=POST>
    <input type="hidden" name="account" value="xiaoming" />
    <input type="hidden" name="amount" value="10000" />
    <input type="hidden" name="for" value="hacker" />
</form>
<script> document.forms[0].submit(); </script> 
```
访问该页面后，表单会自动提交，相当于模拟用户完成了一次`POST`操作。

`POST`类型的攻击通常比`GET`要求更加严格一点，但仍并不复杂。任何**个人网站**、**博客**，**被黑客上传页面的网站**都有可能是发起攻击的来源，后端接口不能将安全寄托在仅允许POST上面。
#### 链接类型的CSRF
链接类型的`CSRF`并不常见，比起其他两种用户打开页面就中招的情况，这种需要用户点击链接才会触发。这种类型通常是在论坛中发布的图片中嵌入恶意链接，或者以广告的形式诱导用户中招，攻击者通常会以比较夸张的词语**诱骗用户点击**
```html
<a href="http://test.com/csrf/withdraw.php?amount=1000&for=hacker" taget="_blank">
  重磅消息！！
  <a/>
```
### CSRF的特点

- 攻击一般发起在第三方网站，而不是被攻击的网站。被攻击的网站无法防止攻击发生
- 攻击利用受害者在被攻击网站的登录凭证，冒充受害者提交操作；而不是直接窃取数据
- 整个过程攻击者并不能获取到受害者的登录凭证，仅仅是"冒用"
- 跨站请求可以用各种方式：`图片url`、`超链接`、`CORS`、`Form提交`等等。部分请求方式可以直接嵌入在第三方论坛、文章中，**难以进行追踪**

### CSRF防范措施
由上面对`CSRF`的介绍我们知道了，`CSRF`通常发生在第三方域名，并且`CSRF`攻击者不能获取到受害者的`cookie`等信息，只是借用他们的登录状态来伪造请求。所以我们可以针对这两点来制定防范措施：
#### 同源检测
既然`CSRF`大多来自第三方网站，那么我们就直接禁止第三方域名（或者不受信任的域名）对我们发起请求。
在`HTTP`协议中，每一个异步请求都会携带两个`Header`，用于标记来源域名：
- Origin Header
- Referer Header

这两个`Header`在浏览器发起请求时，大多数情况会自动带上，并且不能由前端自定义内容。 服务器可以通过解析这两个`Header`中的域名，确定请求的来源域。同时服务器应该优先检测 `Origin`。为了安全考虑，相比于 `Referer`，`Origin` 只包含了域名而不带路径。
#### CSRF Token
- 在浏览器向服务器发起请求时，服务器生成一个 `CSRF Token`。`CSRF Token` 其实就是服务器生成的随机字符串，然后将该字符串植入到返回的页面中，通常是放到表单的隐藏输入框中，这样能够很好的保护 `CSRF Token` 不被泄漏；
- 当浏览器再次发送请求的时候，就需要携带这个 `CSRF Token` 值一起提交
- 服务器验证 `CSRF Token` 是否一致；从第三方网站发出的请求是无法获取用户页面中的 `CSRF Token` 值的

#### 给 Cookie 设置合适的 `SameSite`
当从 `A` 网站登录后，会从响应头中返回服务器设置的 `Cookie` 信息，而如果 `Cookie` 携带了 `SameSite=strict` 则表示完全禁用第三方站点请求头携带 `Cookie`，比如当从 B 网站请求 A 网站接口的时候，浏览器的请求头将不会携带该 `Cookie`。

`Samesite`取值
- `Samesite=Strict`，这种称为严格模式，表明这个 `Cookie` 在任何情况下都不可能作为第三方 `Cookie`
- `Samesite=Lax`，这种称为宽松模式，比 `Strict` 放宽了点限制：假如这个请求是这种请求（改变了当前页面或者打开了新页面）且同时是个`GET`请求，则这个`Cookie`可以作为第三方`Cookie`。（默认）
- `None` 任何情况下都会携带

## ClickJacking(点击劫持)
`Clickjacking(点击劫持)`是一种通过视觉欺骗的手段来达到攻击目的手段。往往是攻击者将目标网站通过 `iframe` 嵌入到自己的网页中，通过 `opacity` 等手段设置 `iframe` 为透明的，使得肉眼不可见，这样一来当用户在攻击者的网站中操作的时候，比如点击某个按钮(这个按钮的顶层其实是 `iframe`)，从而实现目标网站被点击劫持。

### 防范措施
- 在`HTTP`中加入 `X-FRAME-OPTIONS` 属性，此属性控制页面是否可被嵌入 `iframe` 中
- 判断当前网页是否被 iframe 嵌套

`X-FRAME-OPTIONS` 属性取值
- `DENY`：不能被所有网站嵌套或加载；
- `SAMEORIGIN`：只能被同域网站嵌套或加载
- `ALLOW-FROM URL`：可以被指定网站嵌套或加载



