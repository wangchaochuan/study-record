# 前端应该知道的浏览器基础知识

浏览器是一个多进程的架构

## 进程与线程

### 概念
从本质上说，进程和线程都是 CPU 工作时间片的一个描述：
- 进程是对运行时程序的封装，是系统进行资源调度和分配的的基本单位，实现了操作系统的并发；
- 线程是进程的子任务，是CPU调度和分派的基本单位，用于保证程序的实时性，实现进程内部的并发；线程是操作系统可识别的最小执行和调度单位。

**进程是资源分配的最小单位，线程是CPU调度的最小单位。**

做个简单的比喻：进程=火车，线程=车厢，线程在进程下行进（单纯的车厢无法运行

### 区别

- **一个线程只能属于一个进程，而一个进程可以有多个线程**，但至少有一个线程。线程依赖于进程而存在。
- **进程在执行过程中拥有独立的内存单元，而多个线程共享进程的内存**。（资源分配给进程，同一进程的所有线程共享该进程的所有资源。同一进程中的多个线程共享代码段（代码和常量），数据段（全局变量和静态变量），扩展段（堆存储）。但是每个线程拥有自己的栈段，栈段又叫运行时段，用来存放所有局部变量和临时变量。）
- **进程是资源分配的最小单位，线程是CPU调度的最小单位；**
-  **系统开销**： 由于在创建或撤消进程时，系统都要为之分配或回收资源，如内存空间、I／o设备等。因此，操作系统所付出的开销将显著地大于在创建或撤消线程时的开销。类似地，在进行进程切换时，涉及到整个当前进程CPU环境的保存以及新被调度运行的进程的CPU环境的设置。而线程切换只须保存和设置少量寄存器的内容，并不涉及存储器管理方面的操作。可见，**进程切换的开销也远大于线程切换的开销**。
- **通信**：由于同一进程中的多个线程具有相同的地址空间，致使它们之间的同步和通信的实现，也变得比较容易。进程间通信IPC，线程间可以直接读写进程数据段（如全局变量）来进行通信——需要进程同步和互斥手段的辅助，以保证数据的一致性。在有的系统中，线程的切换、同步和通信都无须操作系统内核的干预
-  **进程编程调试简单可靠性高，但是创建销毁开销大；线程正相反，开销小，切换速度快，但是编程调试相对复杂。**
-  **进程间不会相互影响 ；线程一个线程挂掉将导致整个进程挂掉**
-  **进程适应于多核、多机分布；线程适用于多核**

### 进程间通信的方式(了解即可)

进程间通信主要包括**管道**、**系统`IPC`**（包括消息队列、信号量、信号、共享内存等）、以及**套接字`socket`**。

#### 管道
管道主要包括**匿名管道**和**命名管道**:管道可用于具有亲缘关系的父子进程间的通信，命名管道除了具有管道所具有的功能外，它还允许无亲缘关系进程间的通信 

##### 匿名管道`PIPE`

- 它是**半双工**的（即数据只能在一个方向上流动），具有固定的读端和写端
- 它只能用于具有**亲缘关系**的进程之间的通信（也是父子进程或者兄弟进程之间）
- 它可以看成是一种特殊的文件，对于它的读写也可以使用普通的read、write等函数。但是它不是普通的文件，并不属于其他任何文件系统，并且只存在于内存中。

##### 命名管道`FIFO`
- `FIFO`可以在无关的进程之间交换数据
- `FIFO`有路径名与之相关联，它以一种特殊设备文件形式存在于文件系统中。

#### 系统IPC

##### 消息队列

消息队列，是消息的链接表，存放在内核中。一个消息队列由一个标识符（即队列`ID`）来标记。 (消息队列克服了信号传递信息少，管道只能承载无格式字节流以及缓冲区大小受限等特点)具有写权限得进程可以按照一定得规则向消息队列中添加新信息；对消息队列有读权限得进程则可以从消息队列中读取信息

**特点：**

- 消息队列是**面向记录**的，其中的消息具有特定的格式以及特定的优先级
- 消息队列**独立于发送与接收进程**。进程终止时，消息队列及其内容并不会被删除
- 消息队列可以**实现消息的随机查询**,消息不一定要以先进先出的次序读取,也可以按消息的类型读取


##### 信号量
信号量（`semaphore`）与已经介绍过的 `IPC` 结构不同，它是一个计数器，可以用来控制多个进程对共享资源的访问。**信号量用于实现进程间的互斥与同步，而不是用于存储进程间通信数据**。

**特点：**
- 信号量用于**进程间同步**，若要在进程间传递数据需要结合共享内存
- 信号量基于**操作系统的 `PV` 操作**，程序对信号量的操作都是原子操作
- **每次对信号量的 PV 操作不仅限于对信号量值加 1 或减 1，而且可以加减任意正整数**
- 支持信号量组

##### 信号
信号是一种比较复杂的通信方式，用于通知接收进程某个事件已经发生。

##### 共享内存
它使得**多个进程可以访问同一块内存空间，不同进程可以及时看到对方进程中对共享内存中数据得更新**。这种方式需要依靠某种同步操作，如互斥锁和信号量等

**特点：**
- **共享内存是最快的一种IPC，因为进程是直接对内存进行存取**
- 因为多个进程可以同时操作，所以需要进行同步
- 信号量+共享内存通常结合在一起使用，信号量用来同步对共享内存的访问

#### 套接字`SOCKET`

`socket`也是一种进程间通信机制，与其他通信机制不同的是，它可用于不同主机之间的进程通信。

### 线程间通信的方式(了解即可)

#### 临界区
通过多线程的串行化来访问公共资源或一段代码，速度快，适合控制数据访问
#### 互斥量`Synchronized/Lock`
采用互斥对象机制，只有拥有互斥对象的线程才有访问公共资源的权限。因为互斥对象只有一个，所以可以保证公共资源不会被多个线程同时访问
#### 信号量`Semphare`
为控制具有有限数量的用户资源而设计的，它允许多个线程在同一时刻去访问同一个资源，但一般需要限制同一时刻访问此资源的最大线程数目
#### 事件(信号) - `Wait/Notify`
通过通知操作的方式来保持多线程同步，还可以方便的实现多线程优先级的比较操作进程间通信的方式

## 如何实现浏览器内多个标签页之间的通信
实现多个标签页之间的通信，本质上都是通过**中介者模式**来实现的。因为标签页之间没有办法直接通信，因此我们可以找一个中介者，让标签页和中介者进行通信，然后让这个中介者来进行消息的转发。通信方法如下：
### 使用 `websocket` 协议
因为 `websocket` 协议可以实现服务器推送，所以服务器就可以用来当做这个中介者。标签页通过向服务器发送数据，然后由服务器向其他标签页推送转发
### 使用 `ShareWorker` 的方式
`hareWorker` 会在页面存在的生命周期内创建一个唯一的线程，并且开启多个页面也只会使用同一个线程。这个时候共享线程就可以充当中介者的角色。标签页间通过共享一个线程，然后通过这个共享的线程来实现数据的交换。
### 使用 `localStorage` 的方式
我们可以在一个标签页对 `localStorage` 的变化事件进行监听，然后当另一个标签页修改数据的时候，我们就可以通过这个监听事件来获取到数据。这个时候 `localStorage` 对象就是充当的中介者的角色。
### 使用 `postMessage` 方法
如果我们能够获得对应标签页的引用，就可以使用 `postMessage` 方法，进行通信。

## 为什么需要浏览器缓存

所谓的浏览器缓存指的是**浏览器将用户请求过的静态资源，存储到电脑本地磁盘中，当浏览器再次访问时，就可以直接从本地加载，不需要再去服务端请求了**。

对于浏览器的缓存，**主要针对的是前端的静态资源**，在发起请求之后，拉取相应的静态资源，**并保存在本地**。如果服务器的静态资源没有更新，那么在下次请求的时候，就直接从本地读取即可，如果服务器的静态资源已经更新，那么我们再次请求的时候，就到服务器拉取新的资源，并保存在本地。**这样就大大的减少了请求的次数，提高了网站的性能**。这就要用到浏览器的缓存策略了。

### 使用浏览器缓存的优点

- 减少了服务器的负担，提高了网站的性能
- 加快了客户端网页的加载速度
- 减少了多余网络数据传输

## 点击刷新按钮或者按 `F5`、按 `Ctrl+F5` （强制刷新）、地址栏回车有什么区别

### 点击刷新按钮或者按 `F5`
浏览器直接对本地的缓存文件过期，但是会带上`If-Modifed-Since`，`If-None-Match`，这就意味着服务器会对文件检查新鲜度，返回结果可能是 `304`，也有可能是 `200`。

### 用户按 `Ctrl+F5`（强制刷新）
浏览器不仅会对本地文件过期，而且不会带上 `If-Modifed-Since`，`If-None-Match`，相当于之前从来没有请求过，返回结果是 `200`。

### 地址栏回车
浏览器发起请求，按照正常流程，本地检查是否过期，然后服务器检查新鲜度，最后返回内容

## 浏览器本地存储的方式
### Cookie
`Cookie`是最早被提出来的本地存储方式，在此之前，服务端是无法判断网络中的两个请求是否是同一用户发起的，为解决这个问题，`Cookie`就出现了。`Cookie`的大小只有`4kb`，它是一种纯文本文件，每次发起HTTP请求都会携带`Cookie`。

`Cookie`的特性:
- `Cookie`一旦创建成功，名称就无法修改
- `Cookie`是无法跨域名的，也就是说`a`域名和`b`域名下的`cookie`是无法共享的，这也是由`Cookie`的隐私安全性决定的，这样就能够阻止非法获取其他网站的`Cookie`
- 每个域名下`Cookie`的数量不能超过20个，每个`Cookie`的大小不能超过`4kb`
- 有安全问题，如果`Cookie`被拦截了，那就可获得session的所有信息，即使加密也于事无补，无需知道`cookie`的意义，只要转发`cookie`就能达到目的
- `Cookie`在请求一个新的页面的时候都会被发送过去

如果需要域名之间跨域共享Cookie，有两种方法
- 使用Nginx反向代理
- 在一个站点登陆之后，往其他网站写`Cookie`。服务端的`Session`存储到一个节点，`Cookie`存储`sessionId`

### `LocalStorage`
`LocalStorage`是`HTML5`新引入的特性，由于有的时候我们存储的信息较大，`Cookie`就不能满足我们的需求，这时候`LocalStorage`就派上用场了。

`LocalStorage`的优点:
- 在大小方面，`LocalStorage`的大小一般为`5MB`，可以储存更多的信息
- `LocalStorage`是持久储存，并不会随着页面的关闭而消失，除非主动清理，不然会永久存在
- 仅储存在本地，不像`Cookie`那样每次`HTTP`请求都会被携带

`LocalStorage`的缺点:
- 存在浏览器兼容问题，IE8以下版本的浏览器不支持
- 如果浏览器设置为隐私模式，那我们将无法读取到`LocalStorage`
- `LocalStorage`受到同源策略的限制，即端口、协议、主机地址有任何一个不相同，都不会访问

### `SessionStorage`
`SessionStorage`和`LocalStorage`都是在`HTML5`才提出来的存储方案，`SessionStorage` 主要用于临时保存同一窗口(或标签页)的数据，刷新页面时不会删除，关闭窗口或标签页之后将会删除这些数据。

`SessionStorage`与`LocalStorage`对比：
`SessionStorage`和`LocalStorage`都在本地进行数据存储；
`SessionStorage`也有同源策略的限制，但是`SessionStorage`有一条更加严格的限制，`SessionStorage`只有在同一浏览器的同一窗口下才能够共享；
`LocalStorage`和`SessionStorage`都不能被爬虫爬取；

## 同源策略和跨域

同源策略是指在`Web`浏览器中，允许某个网页脚本访问另一个网页的数据，但前提是这两个网页必须有相同的协议(`protocol`)、域名(`domain`)和端口号(`port`)，一旦两个网站满足上述条件，这两个网站就被认定为具有相同来源。

同源政策主要限制了三个方面：
- 当前域下的 `js` 脚本不能够访问其他域下的 `cookie``、localStorage` 和 `indexDB`
- 当前域下的 `js` 脚本不能够操作访问操作其他域下的 `DOM`
- 当前域下 `ajax` 无法发送跨域请求

同源政策的目的主要是为了**保证用户的信息安全**，**它只是对 `js` 脚本的一种限制，并不是对浏览器的限制**，对于一般的 `img`、或者`script` 脚本请求都不会有跨域的限制，这是因为这些操作都不会通过响应结果来进行可能出现安全问题的操作

**跨域是指浏览器不能执行其他网站的脚本**，它是由**浏览器的同源策略造成的**,是浏览器对 `javascript` 施加的安全限制，防止他人恶意攻击网站

## 如何解决跨越问题
### CORS
`CORS`是一个`W3C标准`，全称是"**跨域资源共享**"(`Cross-origin resource sharing`)。

`CORS`需要浏览器和服务器同时支持。目前，所有浏览器都支持该功能。

整个`CORS`通信过程，都是浏览器自动完成，不需要用户参与。对于开发者来说，`CORS`通信与同源的`AJAX`通信没有差别，代码完全一样。浏览器一旦发现`AJAX`请求跨源，就会自动添加一些附加的头信息，有时还会多出一次附加的请求，但用户不会有感觉。

因此，实现`CORS`通信的关键是服务器。只要服务器实现了`CORS`接口，就可以跨源通信。

### JSONP

`jsonp`的原理就是利用`<script>`标签没有跨域限制，通过`<script>`标签`src`属性，发送带有`callback`参数的`GET`请求，服务端将接口返回数据拼凑到`callback`函数中，返回给浏览器，浏览器解析执行，从而前端拿到`callback`函数返回的数据

`JSONP`只支持`GET`请求，`CORS`支持所有类型的`HTTP`请求。`JSONP`的优势在于支持老式浏览器，以及可以向不支持`CORS`的网站请求数据.

### `postMessage`
`postMessage`是`HTML5` `XMLHttpRequest Level 2`中的`API`，且是为数不多可以跨域操作的`window`属性之一，它可用于解决以下方面的问题:
- 页面和其打开的新窗口的数据传递
- 多窗口之间消息传递
- 页面与嵌套的iframe消息传递
- 上面三个场景的跨域数据传递

## Node中间件代理(proxy正向代理)(两次跨域)
实现原理：同源策略是浏览器需要遵循的标准，而如果是服务器向服务器请求就无需遵循同源策略。 代理服务器，需要做以下几个步骤：

- 接受客户端请求 。
- 将请求 转发给服务器。
- 拿到服务器 响应 数据。

## `nginx`反向代理
实现原理类似于`Node`中间件代理，需要你搭建一个中转`nginx`服务器，用于转发请求。

使用`nginx`反向代理实现跨域，是**最简单的跨域方式**。只需要修改`nginx`的配置即可解决跨域问题，支持所有浏览器，支持session，不需要修改任何代码，并且不会影响服务器性能。

实现思路：通过`nginx`配置一个代理服务器（域名与`domain1`相同，端口不同）做跳板机，反向代理访问`domain2`接口，并且可以顺便修改`cookie`中`domain`信息，方便当前域`cookie`写入，实现跨域登录。

## 正向代理和反向代理的区别
### 正向代理
客户端想获得一个服务器的数据，但是因为种种原因无法直接获取。于是客户端设置了一个代理服务器，并且指定目标服务器，之后代理服务器向目标服务器转交请求并将获得的内容发送给客户端。这样本质上起到了对真实服务器隐藏真实客户端的目的。实现正向代理需要修改客户端，比如修改浏览器配置

### 反向代理
服务器为了能够将工作负载分不到多个服务器来提高网站性能 (负载均衡)等目的，当其受到请求后，会首先根据转发规则来确定请求应该被转发到哪个服务器上，然后将请求转发到对应的真实服务器上。这样本质上起到了对客户端隐藏真实服务器的作用。 一般使用反向代理后，需要通过修改 `DNS` 让域名解析到代理服务器 `IP`，这时浏览器无法察觉到真正服务器的存在，当然也就不需要修改配置了。

![](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/ea0a97dea4ab411fb9c20b0856b64c54~tplv-k3u1fbpfcp-zoom-in-crop-mark:4536:0:0:0.awebp)