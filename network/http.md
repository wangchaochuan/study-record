# http协议零碎知识点

## GET和POST的请求的区别
POST 和 GET 是 HTTP 请求的两种方法，其区别如下：
### 应用场景
- GET请求是**一个幂等的请求**,一般用于对服务器资源不会产生影响的场景,比如获取一些静态资源;
- POST请求**不是一个幂等的请求**,一般用于对服务器资源会产生影响的场景,比如注册用户之类的操作;

tips:**幂等是指一个请求方法执行多次和仅执行一次的效果完全相同**
PUT请求也是幂等的。

### 是否缓存
因为两者应用场景不同，浏览器一般会对 Get请求缓存，但很少对 Post请求缓存

### 传参方式不同
GET请求通过查询字符串传参,Post请求一般通过请求体传参,当然也可以通过查询字符串传参,只是一般不这么用

### 安全性
GET请求是通过查询字符串传参的,这种方式将参数放入了url中一起发送到了服务端,这种做法是不太安全的,因为请求的url会被保留在记录中。因此,POST请求安全性比GET请求安全性更高。

### 请求长度
由于浏览器对url长度有限制,所以会影响GET请求发送数据时的长度;而POST请求将请求参数放在了请求体里,所以没有这个限制。

### 参数类型
get参数只允许ASCII字符，post 的参数传递支持更多的数据类型(如文件、图片)。

### 发送请求次数
GET请求只会发送一次请求,而POST会发送两次请求。

tip:**为什么post请求会发送两次请求?**


1、第一次请求为`options`预检请求,状态码为:204
那么发送`options`请求的目的是什么呢?主要有一下两个作用
- 询问服务器是否支持修改的请求头，如果服务器支持，则在第二次中发送真正的请求
- 检测服务器是否为同源请求,是否支持跨域
  
2、第二次为真正的`post`请求


## 常见的HTTP请求头和响应头

### HTTP Request Header

- **Accept**:浏览器能够处理的内容类型
- **Accept-Charset**:浏览器能够显示的字符集
- **Accept-Encoding**：浏览器能够处理的压缩编码
- **Accept-Language**：浏览器当前设置的语言
- **Connection**：浏览器与服务器之间连接的类型
- **Cookie**：当前页面设置的任何Cookie
- **Host**：发出请求的页面所在的域
- **Referer**：发出请求的页面的URL
- **User-Agent**：浏览器的用户代理字符串


### HTTP Responses Header

- **Date**：表示消息发送的时间，时间的描述格式由rfc822定义
- **server**:服务器名称
- **Connection**：浏览器与服务器之间连接的类型
- **Cache-Control**：控制HTTP缓存
- **content-type**:表示后面的文档属于什么`MIME`类型

## 常见的HTTP请求方法
- GET: 向服务器获取数据；
- POST：发送数据给服务器，通常会造成服务器资源的新增修改；
- PUT：用于全量修改目标资源(看接口，也可以用于添加)；
- PATCH：用于对资源进行部分修改
- DELETE：用于删除指定的资源；
- HEAD：获取报文首部，与GET相比，不返回报文主体部分；使用场景是比如下载一个大文件前，先获取其大小再决定是否要下载，以此可以节约宽带资源
- OPTIONS：(浏览器自动执行)、询问支持的请求方法，用来跨域请求、预检请求、判断目标是否安全；
- CONNECT：要求在与代理服务器通信时建立管道，使用管道进行TCP通信；(把服务器作为跳板，让服务器代替用户去访问其他网页，之后把数据原原本本的返回给用户)
- TRACE: 该方法会让服务器原样返回任意客户端请求的信息内容，主要⽤于测试或诊断

## OPTIONS请求方法及使用场景
OPTIONS是除了GET和POST之外的其中一种 HTTP请求方法。(浏览器自动执行)
OPTIONS方法是用于请求获得由`Request-URI`标识的资源在请求/响应的通信过程中可以使用的功能选项。通过这个方法，客户端可以在**采取具体资源请求之前，决定对该资源采取何种必要措施，或者了解服务器的性能**。该请求方法的响应不能缓存。

OPTIONS请求方法的主要用途有两个：
- 获取服务器支持的所有HTTP请求方法；
- 用来检查访问权限。例如：在进行 CORS 跨域资源共享时，对于复杂请求，就是使用 OPTIONS 方法发送**嗅探请求**，以判断是否有对指定资源的访问权限。

## XMLHTTPRequest对象

Ajax的核心是XMLHTTPRequest。它是一种支持异步请求的技术。 XMLHTTPRequest使您可以使用JavaScript向服务器提出请求并处理响应，而不阻塞用户。可以在页面加载以后进行页面的局部更新

### 使用XHR

- 实例化ajax对象
```javascript
const xhr = new XMLHttpRequest();
```
- 创建HTTP请求
```javascript
/**
 * @params method 请求方法 GET|POST|PUT|DELETE
 * @params url    请求地址 String
 * @params async  是否是异步请求,可选,默认为true Boolean
 */
xhr.open("post", "http://localhost:3008/api/login",true);
```

- 设置请求头
```javascript
/**
 * @params key    请求头的key    String
 * @params value  请求头的value  String
 */
xhr.setRequestHeader("Content-type","application/json");
```

- 注册回调函数

```javascript
// 方式一
// onload事件 ：  接收服务器响应的数（一次请求，只会执行一次）
xhr.onload = function(){
    console.log(xhr.responseText);
}
// 方式二
/**
 * onreadystatechang事件 : 作用与onload事件一致（一次请求，会执行多次）
 * XMLHttpRequest对象的状态码 （xhr.readyState）
 * 0: 请求未建立  (创建了xhr对象，但是还没调用open)
 * 1: 服务器连接已建立
 * 2. 请求已接收  (send之后,服务器已经接收了请求)
 * 3. 请求处理中
 * 4. 请求已完成，且响应已就绪  (4状态码等同于onload事件)
 */
xhr.onreadystatechange = function() {
    if(xhr.readyState === 4){
        console.log(xhr.responseText);
    }
}
```

- 发送请求
```javascript
/**
 * @params body    可选参数,请求主体,如果请求方法是 GET 或者 HEAD，则应将请求主体设置为 null
 */
xhr.send();
```

```javascript
// 1.实例化ajax对象
const xhr = new XMLHttpRequest();
// 2.创建http请求
xhr.open("post", "http://localhost:3008/api/login",true);
// 3.设置请求头
xhr.setRequestHeader("Content-type","application/json");
// 4.设置回调函数
xhr.onreadystatechange = function() {
    if(xhr.readyState === 4){
        console.log(xhr.responseText);
    }
}
// 5.发送请求
xhr.send();
```

### ajax请求如何取消
#### 原生xhr取消请求
```javascript
const xhr = new XMLHttpRequest();
xhr.abort();
```

#### axios取消请求
传递一个 `executor` 函数到 `CancelToken` 的构造函数来创建 `cancel token`
```javascript
const CancelToken = axios.CancelToken;
let cancel;
​
axios.get('/user/12345', {
  cancelToken: new CancelToken(function executor(c) {
    // executor 函数接收一个 cancel 函数作为参数
    cancel = c;
  })
});
​
// cancel the request
cancel();
```

### 取消ajax请求的意义
- 已发出的请求可能仍然会到达后端
- 取消后续的回调处理，避免多余的回调处理，以及特殊情况，先发出的后返回，导致回调中的数据错误覆盖
- 取消loading效果，以及该请求的其他交互效果，特别是在单页应用中，A页面跳转到B页面之后，A页面的请求应该取消，否则回调中的一些处理可能影响B页面
- 超时处理，错误处理等都省去了，节约资源

## HTTP 1.0 和 HTTP 1.1 之间有哪些区别？

### 连接方面
http1.0 默认使用**非持久连接**，而 http1.1 默认使用**持久连接**(`Connection: Keep-Alive`)。http1.1 通过使用持久连接来使多个 http 请求复用同一个 TCP 连接，以此来避免使用非持久连接时每次需要建立连接的时延。

### 资源请求方面
在 http1.0 中，存在一些浪费带宽的现象，例如客户端只是需要某个对象的一部分，而服务器却将整个对象送过来了，并且不支持断点续传功能，http1.1 则在请求头引入了 `range` 头域，它允许只请求资源的某个部分，即返回码是 206（Partial Content），这样就方便了开发者自由的选择以便于充分利用带宽和连接。

### 缓存方面
在 http1.0 中主要使用 header 里的 `Expires` 来做为缓存判断的标准，http1.1 则引入了更多的缓存控制策略，例如 `cache-control`、`Etag`、`if-none-matched`、`last-modified`、`if-modified-since` 等更多可供选择的缓存头来控制缓存策略

### http1.1 中新增了 host 字段,用来指定服务器的域名
http1.0 中认为每台服务器都绑定一个唯一的 IP 地址，因此，请求消息中的 URL 并没有传递主机名(`hostname`)。但随着虚拟主机技术的发展，在一台物理服务器上可以存在多个虚拟主机，并且它们共享一个IP地址。因此有了 host 字段，这样就可以将请求发往到同一台服务器上的不同网站。
### 新增请求方法
http1.1 相对于 http1.0 还新增了很多请求方法，如 `PUT`、`HEAD`、`OPTIONS` 等

## HTTP 2.0相对于HTTP 1.1 的新特性

### 二进制协议
`HTTP2`是一个二进制协议。在`HTTP1.1`中,报文的头信息必须是文本,数据体可以是文本也可以是二进制。`HTTP2`是则是一个彻底的二进制协议,头信息和数据体都是二进制,并且统称为`帧`,可以分为头信息帧和数据帧。帧的概念是它实现多路复用的基础。

为什么使用二进制协议
- **性能**。二进制协议的解析效率超高,几乎没有解析代价
- **体积**。二进制协议没有冗余字段,体积小,占用带宽少
- 压缩及`HTTPS技术`弱化了文本协议可读性好的价值

### 多路复用
`HTTP2`实现了多路复用。`HTTP2`仍然复用`TCP`连接,但是在一个连接里客户端和服务端都可以同时发送多个请求或响应,而且不用按照顺序一一发送,这样就避免了`队头阻塞`的问题。

什么是队头阻塞呢？

队头阻塞是指当多个`HTTP`请求同时存在时,如果队头的请求还在处理中时,那么后续的请求会被阻塞这样一种现象。队头阻塞是由 HTTP 基本的`请求-应答`模型所导致的。`HTTP` 规定报文必须是`一发一收`，这就形成了一个先进先出的`串行`队列。队列里的请求是没有优先级的，只有入队的先后顺序，排在最前面的请求会被最优先处理。如果队首的请求因为处理的太慢耽误了时间，那么队列里后面的所有请求也不得不跟着一起等待，结果就是其他的请求承担了不应有的时间成本，造成了队头堵塞的现象

队头阻塞的解决方案
- **并发连接**。对于一个域名允许分配多个长连接，那么相当于增加了任务队列，不至于一个队伍的任务阻塞其它所有任务。
- **域名分片**。将域名分出很多二级域名，它们都指向同样的一台服务器，能够并发的长连接数变多，解决了队头阻塞的问题。

### 数据流
`HTTP2` 使用了数据流的概念,因为 `HTTP2` 的数据包是不按顺序发送的,同一个连接里面连续的数据包，可能属于不同的请求。因此,必须要对数据包做标记,指出它属于哪个请求。`HTTP2` 将每个请求或回应的所有数据包,称为一个数据流。每个数据流都有一个独一无二的编号。数据包发送时,都必须标记数据流 ID ,用来区分它属于哪个数据流。

### 头信息压缩
`HTTP2` 实现了头信息压缩,由于 `HTTP 1.1` 协议不带状态,每次请求都必须附上所有信息。所以,请求的很多字段都是重复的,比如 `Cookie` 和 `User Agent` ,一模一样的内容,每次请求都必须附带,这会浪费很多带宽,也影响速度。`HTTP2` 对这一点做了优化,引入了头信息压缩机制。一方面,头信息使用 `gzip` 或 `compress` 压缩后再发送;另一方面,客户端和服务器同时维护一张头信息表,所有字段都会存入这个表,生成一个索引号,以后就不发送同样字段了,只发送索引号,这样就能提高速度了。

### 服务器推送
`HTTP2` 允许服务器未经请求,主动向客户端发送资源,这叫做服务器推送。使用服务器推送提前给客户端推送必要的资源,这样就可以相对减少一些延迟时间。这里需要注意的是 `HTTP2` 下服务器主动推送的是静态资源,和 `WebSocket` 以及使用 `SSE` 等方式向客户端发送即时数据的推送是不同的。举个栗子,假如你向服务器请求`index.html`,那么服务器发下静态资源里有`index.js`和`index.css`,那么它会把这两个静态资源主动推送给你。

## HTTP2的头部压缩算法
`HTTP2`的头部压缩是`HPACK`算法。在客户端和服务器两端建立`字典`,用索引号表示重复的字符串,采用哈夫曼编码来压缩整数和字符串,可以达到`50%~90%`的高压缩率。

具体来说是这样的：
- 在客户端和服务器端使用`首部表`来跟踪和存储之前发送的键值对,对于相同的数据,不再通过每次请求和响应发送;
- 首部表在`HTTP2`的连接存续期内始终存在,由客户端和服务器共同渐进地更新;
- 每个新的首部键值对要么被追加到当前表的末尾,要么替换表中之前的值;

## HTTP 3.0简介
`HTTP3.0`,也称作`HTTP over QUIC`。`HTTP3.0`的核心是`QUIC`(读音`quick`)协议，由`Google`在 2015年提出的`SPDY v3`演化而来的新协议,传统的`HTTP`协议是基于传输层`TCP`的协议,而`QUIC`是基于传输层`UDP`上的协议,可以定义成:`HTTP3.0`基于`UDP`的安全可靠的`HTTP2.0`协议。

`QUIC` 协议针对基于`TCP`和`TLS`的`HTTP2.0`协议解决了下面的问题:
- 减少了TCP三次握手及TLS握手时间。`QUIC`协议是基于`UDP`协议的,本身没有连接的概念,建立连接只需要一次交互,半个握手的时间。
- 多路复用丢包的线头阻塞问题
- 优化重传策略
- 流量控制
- 连接迁移


## HTTP请求报文的是什么样的

请求报⽂有4部分组成:
### 请求行
请求⾏包括：请求⽅法字段、`URL`字段、`HTTP`协议版本字段。它们⽤空格分隔。例如，`GET /index.html HTTP/1.1`

### 请求头部
请求头部由关键字/值对组成，每⾏⼀对，关键字和值⽤英⽂冒号`:`分隔
- User-Agent：产⽣请求的浏览器类型。
- Accept：客户端可识别的内容类型列表。
- Host：请求的主机名，允许多个域名同处⼀个IP地址，即虚拟主机。

### 空行

### 请求体
`post` `put`等请求携带的数据

## HTTP响应报文的是什么样的
请求报⽂有4部分组成
### 响应⾏
由网络协议版本,状态码和状态码的原因短语组成,例如 `HTTP/1.1 200 OK`

### 响应头
响应部⾸组成

### 空行

### 响应体
服务器响应的数据

## HTTP状态码分别代表什么意思

类别 | 原因 | 描述
--- | --- | ---
1xx | `Informational`(信息性状态码) | 接受的请求正在处理
2xx | `Success`(成功状态码) | 请求正常处理完毕
3xx | `Redirection`(重定向状态码) | 需要进行附加操作以完成请求
4xx | `Client Error`(客户端错误状态码) | 服务器无法处理请求
5xx | `Server Error`(服务端错误状态码) | 服务器处理请求出错

### 2xx成功

- 200 `OK`，表示从客户端发来的请求在服务器端被正确处理
- 201 `Created` 请求已经被实现，而且有一个新的资源已经依据请求的需要而建立。通常是在POST请求，或者是某些PUT请求之后创建了内容，进行的返回的响应。
- 202 `Accepted` 请求服务器已接受，但是尚未处理，不保证完成请求。适合异步任务或者说需要处理时间比较长的请求，避免HTTP链接一直占用。
- 204 `No content`，表示请求成功，但响应报文不含实体的主体部分
- 205 `Reset Content`，表示请求成功，但响应报文不含实体的主体部分，但是与 204 响应不同在于要求请求方重置内容

### 3XX 重定向

- 301 `moved permanently`，永久性重定向，表示资源已被分配了新的 URL
- 302 `found`，临时性重定向，表示资源临时被分配了新的 URL，支持搜索引擎优化
- 303 `see other`，表示资源存在着另一个 URL，应使用 GET 方法获取资源
- 304 `not modified`，自从上次请求后，请求的网页内容未修改过。服务器返回此响应时，不会返回网页内容。(**协商缓存**)
- 307 `temporary redirect`，临时重定向，和302含义类似，但是期望客户端保持请求方法不变向新的地址发出请求

### 4XX 客户端错误

- 400 `bad request`，请求报文存在语法错误(传参格式不正确)
- 401 `unauthorized`，表示发送的请求需要有通过 HTTP 认证的认证信息(没有权限)
- 403 `forbidden`，表示对请求资源的访问被服务器拒绝
- 404 `not found`，表示在服务器上没有找到请求的资源
- 408 `Request Timeout` 客户端请求超时
- 409 `Confict` 请求的资源可能引起冲突

### 5XX 服务器错误

- 500 `internal sever error`，表示服务器端在执行请求时发生了错误
- 501 `Not Implemented`，表示服务器不支持当前请求所需要的某个功能
- 503 `service unavailable`，表明服务器暂时处于超负载或正在停机维护，无法处理请求

